1\多轮对话
百炼提供的 DeepSeek API 默认不会记录您的历史对话信息。多轮对话功能可以让大模型“拥有记忆”，满足如追问、信息采集等需要连续交流的场景。如果您使用 DeepSeek-R1 类模型，会收到reasoning_content字段（思考过程）与content（回复内容），您可以将content字段通过{'role': 'assistant', 'content':API 返回的content}添加到上下文，无需添加reasoning_content字段。
您可以通过 OpenAI SDK 或 OpenAI 兼容的 HTTP 方式使用多轮对话功能。
```
import OpenAI from "openai";

const openai = new OpenAI(
    {
        // 若没有配置环境变量，请用百炼API Key将下行替换为：apiKey: "sk-xxx",
        apiKey: process.env.DASHSCOPE_API_KEY,
        baseURL: "https://dashscope.aliyuncs.com/compatible-mode/v1"
    }
);
const completion = await openai.chat.completions.create({
    model: "deepseek-r1",  // 此处以 deepseek-r1 为例，可按需更换模型名称。
    messages: [
        { role: "user", content: "9.9和9.11谁大" }
    ],
});
console.log("思考过程：")
console.log(completion.choices[0].message.reasoning_content)
console.log("最终答案：")
console.log(completion.choices[0].message.content)
```
返回结果

'''
思考过程：

嗯，我现在要比较9.9和9.11这两个数，看看哪个更大。刚开始的时候，可能会有点混淆，特别是因为小数点后的位数不一样，所以需要仔细分析一下。让我一步一步来思考这个问题。

首先，我知道比较小数的时候，应该先比较整数部分，如果整数部分大的那个数就更大。如果整数部分相同，再依次比较小数部分的每一位数字，直到找到差异为止。这里两个数的整数部分都是9，所以整数部分相等，接下来就需要比较小数部分了。

接下来，我需要看看小数部分。9.9的小数部分是0.9，也就是十分位上的数字是9，而百分位上的数字是0，因为9.9其实可以写成9.90。而9.11的小数部分是0.11，十分位是1，百分位是1。现在的问题是，如何比较这两个小数部分的大小。

首先比较十分位上的数字。对于9.9来说，十分位是9，而9.11的十分位是1。显然，9比1大，所以在十分位上，9.9已经比9.11大了。因此，根据小数比较的规则，当十分位上的数字9大于1的时候，整个小数部分9.90就会比0.11大，所以9.9应该比9.11大。

不过，这里可能存在一个常见的误区，就是误以为小数点后的位数越多，数值就越大，但这种情况只有当整数部分相同，并且前面的小数位数也相同的时候才成立。例如，9.11和9.109，这时候需要看更多的位数，但这里的情况不同，因为9.9的十分位已经是9，而9.11的十分位是1，所以即使后面的百分位有数字，也无法超过前面的差异。

为了更直观地理解，可以将两个数都转换成相同的位数，比如将9.9写成9.90，这样比较起来更容易。比较9.90和9.11的话，先看十分位，9比1大，所以9.90更大。因此，9.9比9.11大。

不过，有人可能会问，如果换成其他的比较方式，比如把它们转换成分数来比较，会不会更清楚呢？让我们试试看。9.9其实可以表示为9又9/10，也就是99/10。而9.11则是9又11/100，也就是911/100。现在比较这两个分数的大小，可以将它们通分，找到共同的分母进行比较。

99/10和911/100，通分后的共同分母是100。将99/10转化为分母为100的分数，就是990/100。而911/100保持不变。所以比较990/100和911/100，显然990比911大，所以990/100也就是9.9更大。

或者，把它们都转换成十进制，但这里已经是十进制了，只是需要更明确地写出小数位数。例如，9.9等于9.90，而9.11保持不变。比较的话，9.90中的十分位是9，百分位是0，而9.11中的十分位是1，百分位是1。由于十分位9大于1，所以无论后面的位数如何，9.90已经更大。

另一个可能的思考错误是，可能会有人误以为小数点后的数字是整体比较，比如认为0.11比0.9大，但这是错误的，因为0.11实际上是0.1 + 0.01，而0.9是0.9，显然0.9更大。所以0.9比0.11大，所以整个数9.9比9.11大。

不过，为了确保自己没有错，我还可以用减法来验证。9.9减去9.11等于多少？计算的时候，可以把9.9写成9.90，然后进行减法：

```
 9.90
-9.11
-------
 0.79
```

结果是0.79，这是一个正数，说明9.9比9.11大0.79，所以9.9确实更大。

或者，通过另一种方式，比如将它们都乘以100，变成整数来比较。9.9乘以100是990，9.11乘以100是911，那么显然990大于911，所以原来的9.9大于9.11。

总结一下，无论是通过逐位比较、转换成分数、进行减法还是乘以相同倍数后比较整数，结果都显示9.9比9.11大。因此，可以确定9.9是更大的那个数。

不过，可能有人会疑惑，为什么9.11的位数更多，结果却更小呢？这其实是因为小数点后的位数只有在前面各位相同的情况下，才会影响大小。比如，9.1和9.09，这时候比较的话，9.1的十分位是1，而9.09的十分位是0，所以9.1更大，尽管9.09有两位小数，但前面已经决定了大小。同样的道理，9.9的十分位是9，而9.11的十分位是1，所以不管后面的百分位是什么，9.9已经更大。

还有一种方法是用数轴来想象，9.9位于9.8和10之间，而9.11位于9.1和9.2之间，显然9.9的位置更靠右，也就是更大。

再想想，如果换成钱来理解的话，比如9.9元就是9元9角，而9.11元是9元1角1分，显然9元9角比9元1角1分多，所以9.9元更大。

或者，用时间来做例子，假设是9.9小时和9.11小时，9.9小时等于9小时54分钟（因为0.9小时×60分钟=54分钟），而9.11小时是9小时6.6分钟（0.11×60≈6.6分钟），显然，9小时54分钟比9小时6分钟多得多，所以9.9小时更大。

通过这些不同的例子，都验证了9.9确实比9.11大。因此，可以确定答案是正确的。

最终答案：
9.9比9.11大。

**步骤解析：**

1. **整数部分比较**：两个数的整数部分均为9，因此需进一步比较小数部分。
2. **小数部分对齐位数**：将9.9补全为9.90，与9.11的小数部分对齐（0.90 vs 0.11）。
3. **逐位比较小数部分**：
   - **十分位**：9（来自9.90） > 1（来自9.11），无需继续比较后续位数。
4. **结论**：由于十分位上9 > 1，故9.90（即9.9）大于9.11。

**验证方法：**
- **减法验证**：9.90 - 9.11 = 0.79（正数，说明9.9更大）。
- **分数转换**：9.9 = 990/100，9.11 = 911/100，990 > 911。
- **实际意义**：如货币中9.9元（9元9角）多于9.11元（9元1角1分）。

综上，**9.9 > 9.11**。

``` 
2、流式输出
DeepSeek-R1 类模型可能会输出较长的思考过程，为了降低超时风险，建议您使用流式输出方式调用 DeepSeek-R1 类模型。

import OpenAI from "openai";
import process from 'process';

// 初始化 openai 客户端
const openai = new OpenAI({
    apiKey: process.env.DASHSCOPE_API_KEY, // 从环境变量读取
    baseURL: 'https://dashscope.aliyuncs.com/compatible-mode/v1'
});

let reasoningContent = '';
let answerContent = '';
let isAnswering = false;

async function main() {
    try {
        const stream = await openai.chat.completions.create({
            model: 'deepseek-r1',
            messages: [{ role: 'user', content: '9.9和9.11谁大' }],
            stream: true
        });

        console.log('\n' + '='.repeat(20) + '思考过程' + '='.repeat(20) + '\n');

        for await (const chunk of stream) {
            if (!chunk.choices?.length) {
                console.log('\nUsage:');
                console.log(chunk.usage);
                continue;
            }

            const delta = chunk.choices[0].delta;
            
            // 处理思考过程
            if (delta.reasoning_content) {
                process.stdout.write(delta.reasoning_content);
                reasoningContent += delta.reasoning_content;
            } 
            // 处理正式回复
            else if (delta.content) {
                if (!isAnswering) {
                    console.log('\n' + '='.repeat(20) + '完整回复' + '='.repeat(20) + '\n');
                    isAnswering = true;
                }
                process.stdout.write(delta.content);
                answerContent += delta.content;
            }
        }
    } catch (error) {
        console.error('Error:', error);
    }
}

main();

====================思考过程====================

嗯，今天老师布置了一个问题，要比较9.9和9.11哪个大。一开始看起来好像挺简单的，但仔细想想可能有哪里需要注意的地方吧。让我仔细想想看。

首先，我需要明确这两个数的形式。9.9应该是一个小数，也就是9又十分之九，对吧？而9.11可能是9又百分之十一，也就是9.11。不过有时候小数点后面可能有不同的位数，比如有时候会写成9.1和9.10，这时候位数不同但数值其实是一样的，比如9.1等于9.10，因为后面的0不影响大小。不过这里的情况是9.9和9.11，它们的位数不同，一个是十分位，一个是百分位，所以可能需要转换一下单位来比较。

...

911/100 保持不变

所以比较990/100和911/100，显然990比911大，所以990/100也就是99/10即9.9更大。

所以结论是9.9比9.11大。

不过可能还是有人会混淆，因为看到9.11的小数点后有两位，可能会觉得比一位的大，但实际上是小数点后的每一位代表的是更小的单位。比如十分位是0.1，百分位是0.01，所以第一位小数是十分位，第二位是百分位，所以9.9的十分位是9，也就是0.9，而9.11的十分位是1，百分位是1，所以总共是0.11，所以显然0.9比0.11大很多。

因此，最终的结论应该是9.9大于9.11。
====================完整回复====================

要比较9.9和9.11的大小，可以按照以下步骤进行：

1. **统一小数位数**：将9.9转换为9.90（保持两位小数），以便与9.11直接比较。
2. **逐位比较**：
   - **整数部分**：两者整数部分均为9，相等。
   - **小数部分**：比较0.90（9.90的小数部分）与0.11（9.11的小数部分）。显然，0.90 > 0.11。
3. **结论**：由于小数部分0.90 > 0.11，因此**9.9 > 9.11**。

**答案：9.9比9.11大。**


注意事项
DeepSeek-R1 类模型

不支持的功能

Function Calling、JSON Output、对话前缀续写、上下文硬盘缓存

不支持的参数

temperature、top_p、presence_penalty、frequency_penalty、logprobs、top_logprobs

设置这些参数都不会生效，即使没有输出错误提示。
DeepSeek官方不建议设置 System Message，原文："Avoid adding a system prompt; all instructions should be contained within the user prompt."

DeepSeek-V3：

参数默认值：

temperature：0.7（取值范围是[0:2)）；

top_p：0.6；

presence_penalty：0.95。

不支持设置的参数和功能：frequency_penalty、logprobs、top_logprobs参数；不支持 Function Call、JSON Output 等功能，敬请关注后续动态。
